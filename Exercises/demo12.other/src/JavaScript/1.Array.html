<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数组常见操作</title>
    <style>
        .wayfun {
            width: 10%;
        }

        .describe {
            width: 40%;
        }
    </style>
</head>

<body>
    <table border="1">
        <tr>
            <td class="wayfun">方法名</td>
            <td class="describe">说明</td>
            <td class="wayfun">方法名</td>
            <td class="describe">说明</td>
        </tr>
        <tr>
            <td>toString<span style="color: rgb(131, 150, 238);">转换</td>
            <td>把数组变成字符串,去除了[],内容用逗号链接</td>
            <td>jointoString<span style="color: rgb(131, 150, 238);">转换</td>
            <td>数组中的元素可以按照参数进行链接变成一个字符串</td>
        </tr>
        <tr>
            <td>from<span style="color: rgb(131, 150, 238);">转换</td>
            <td>将类似数组的对象（array-like object）和可遍历（iterable）的对象转为真正的数组</td>
            <td>of<span style="color: rgb(131, 150, 238);">转换</td>
            <td>用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。
                因为参数个数的不同，会导致 Array() 的行为有差异。</td>
        </tr>
        <tr>
            <td>push<span style="color: rgb(216, 142, 46);">添加</span></td>
            <td>在数组的最末尾添加元素; (原数组被修改)</td>
            <td>unshift<span style="color: rgb(216, 142, 46);">添加</span></td>
            <td>在数组的最前面添加一个元素; (原数组被修改)</td>
        </tr>
        <tr>
            <td>pop<span style="color: rgb(216, 142, 46);">删除</span></td>
            <td>不需要参数;在数组的最末尾删除一项; (原数组被修改)</td>
            <td>shift<span style="color: rgb(216, 142, 46);">删除</span></td>
            <td>不需要参数;在数组的最前面删除一项; (原数组被修改)</td>
        </tr>
        <tr>
            <td>reverse</td>
            <td>翻转数组; (原数组被修改)</td>
            <td>filter</td>
            <td>对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组</td>
        </tr>
        <tr>
            <td>sort<span style="color: rgb(15, 241, 117);">排序</span></td>
            <td>数组中元素排序; (默认：从小到大) 默认：按照首个字符的Unicode编码排序;如果第一个相同那么就比较第二个... (原数组被修改)</td>
            <td>concat<span style="color: rgb(143, 114, 248);">连接</span></td>
            <td>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，仅会返回被连接数组的一个副本</td>
        </tr>
        <tr>
            <td>splice<span style="color: rgb(122, 221, 200);">修改</span></td>
            <td>splice(开始索引值，删除几个，替换内容1，替换内容2，...); // 替换和删除;
                改变原数组;返回值是被删除/替换的内容 (原数组被修改)</td>
            <td>fill<span style="color: rgb(122, 221, 200);">修改</span></td>
            <td>用新元素替换掉数组内的元素，可以指定替换下标范围。</td>
        </tr>
        <tr>
            <td>substring和substr<span style="color: rgb(241, 202, 28);">截取</span></td>
            <td>相同点：如果只是写一个参数： substr(startIndex);
                substring(startIndex); 两者的作用都一样：都是是截取字符串从当前下标以后直到字符串最后的字符串片段。
                不同点：第二个参数 substr（startIndex,lenth）：
                第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）
                substring（startIndex, endIndex）： 第二个参数是截取字符串最终的下标 （截取2个位置之间的字符串,‘含头不含尾’</td>
            <td>slice<span style="color: rgb(241, 202, 28);">截取</span></td>
            <td>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 返回选定的元素，该方法不会修改原数组</td>
        </tr>
        <tr>
            <td>indexOf和lastIndexOf<span style="color: rgb(228, 122, 171);">查找</span></td>
            <td>都接受两个参数：查找的值、查找起始位置。 不存在，返回 -1 ；存在，返回位置。
                indexOf 是从前往后查找，
                lastIndexOf 从数组的末尾开始向前查找。
                arrayObject.lastIndexOf(searchvalue,startIndex)
                参数： searchvalue：必需，要查找的项；
                startIndex：可选，起点位置的索引 指定要查找的元素的位置，从此位置开始逆向查找。
                默认为数组的长度减去1(array.length - 1)。
                如果为负值，则表示从倒数第几个开始向前查找，此时查找的方向不变还是从后向前查找。
            </td>
            <td>includes<span style="color: rgb(228, 122, 171);">查找</span></td>
            <td>判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。 indexOf 判断元素是否为 NaN，会判断错误。
                用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。
                译者注：includes() 方法区分大小写。</td>
        </tr>
        <tr>
            <td>find<span style="color: rgb(228, 122, 171);">查找</span></td>
            <td>传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索</td>
            <td>findIndex<span style="color: rgb(228, 122, 171);">查找</span></td>
            <td>传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。</td>
        </tr>
        <tr>
            <td>every</span></td>
            <td>对数组的每一项都运行给定的函数，每一项都返回 ture，则返回 true。</td>
            <td>some</span></td>
            <td>对数组的每一项都运行给定的函数，任意一项都返回 ture，则返回 true</td>
        </tr>
        <tr>
            <td>map<span style="color: rgb(82, 204, 235);">遍历</span></td>
            <td>对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组</td>
            <td>forEach<span style="color: rgb(82, 204, 235);">遍历</span></td>
            <td>数组遍历</td>
        </tr>
        <tr>
            <td>reduce<span style="color: rgb(82, 204, 235);">遍历</span></td>
            <td>该.reduce()方法通过为数组的每个元素执行一个函数并累加结果，将数组缩减为单个值。</td>
            <td>isArray</td>
            <td>判断参数是不是数组,返回布尔值;</td>
        </tr>
        <tr>
            <td>flat</span></td>
            <td>此方法创建一个新数组，其中包含子数组上的holden元素，并将其平整到新数组中。请注意，此方法只能进行一个级别的深度。 (原数组被修改)</td>
            <td>flatMap</span></td>
            <td>该方法将函数应用于数组的每个元素，然后将结果压缩为一个新数组。它在一个函数中结合了flat（）和map（）。 (原数组被修改)</td>
        </tr>

    </table>
    <p>
        <h3>isArray(参数)</h3> 判断参数是不是数组,返回布尔值;<button onclick="isArrayfun()">isArray()</button>
    </p>
    <p>
        <h3>toString()</h3>把数组变成字符串,去除了[],内容用逗号链接;<button onclick="toStringfun()">toString()</button>
    </p>
    <p>
        <h3>join(参数)</h3>数组中的元素可以按照参数进行链接变成一个字符串;<button onclick="joinfun()">join()</button>
    </p>
    <p>
        <h3>push()</h3>在数组的最末尾添加元素;
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="pushfun()">push()</button>
        <br>
        <h3>pop()</h3>不需要参数;在数组的最末尾删除一项;
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="popfun()">pop()</button>
    </p>
    <p>
        <h3>unshift()</h3>在数组的最前面添加一个元素;
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="unshiftfun()">unshift()</button>
        <br>
        <h3>shift()</h3>不需要参数;在数组的最前面删除一项;
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="shiftfun()">shift()</button>
    </p>
    <p>
        <h3>reverse()</h3>翻转数组
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="reversefun()">reverse()</button><br>
        <h3>sort()</h3> 数组中元素排序;
        (默认：从小到大)
        默认：按照首个字符的Unicode编码排序;如果第一个相同那么就比较第二个...
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="sortfun()">sort()</button>
    </p>
    <p>
        <h3>slice()</h3>
        返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。
        返回选定的元素，该方法不会修改原数组。
        <button onclick="slicefun()">slice()</button>
    </p>
    <p>
        <h3>splice( )</h3>splice(开始索引值，删除几个，替换内容1，替换内容2，...);
        // 替换和删除; 改变原数组;返回值是被删除/替换的内容
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="splicefun()">splice()</button>
    </p>
    <p>
        <h3>concat()</h3>
        concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，仅会返回被连接数组的一个副本。
        <button onclick="concatfun()">splice()</button>
    </p>
    <p>
        <h3>substring() 和 substr()</h3>
        相同点：如果只是写一个参数：
        substr(startIndex);
        substring(startIndex);
        两者的作用都一样：都是是截取字符串从当前下标以后直到字符串最后的字符串片段。<br>
        不同点：第二个参数
        substr（startIndex,lenth）： 第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）
        substring（startIndex, endIndex）： 第二个参数是截取字符串最终的下标 （截取2个位置之间的字符串,‘含头不含尾’）
        <button onclick="substringAndSubstr()">substring() 和 substr()</button>
    </p>
    <p>
        <h3>indexOf() 和 lastIndexOf() </h3>
        都接受两个参数：查找的值、查找起始位置。
        不存在，返回 -1 ；存在，返回位置。<br>
        indexOf 是从前往后查找，
        lastIndexOf 从数组的末尾开始向前查找。<br>
        arrayObject.lastIndexOf(searchvalue,startIndex) <br>
        参数：
        searchvalue：必需，要查找的项；
        startIndex：可选，起点位置的索引
        指定要查找的元素的位置，从此位置开始逆向查找。默认为数组的长度减去1(array.length - 1)。
        如果为负值，则表示从倒数第几个开始向前查找，此时查找的方向不变还是从后向前查找。
        <button onclick="indexOfAndLastIndexOf()">indexOf() 和 lastIndexOf()</button>
    </p>
    <p>
        <h3>every()</h3>
        对数组的每一项都运行给定的函数，每一项都返回 ture，则返回 true。
        <button onclick="everyfun()">every()</button>
    </p>
    <p>
        <h3>some()</h3>
        对数组的每一项都运行给定的函数，任意一项都返回 ture，则返回 true。
        <button onclick="somefun()">some()</button>
    </p>
    <p>
        <h3>filter()</h3>
        对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组。
        <button onclick="filterfun()">filter()</button>
    </p>
    <p>
        <h3>map()</h3>
        对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组。
        <button onclick="mapfun()">map()</button>
    </p>
    <p>
        <h3>forEach() 数组遍历</h3>
        <button onclick="forEachfun()">forEach()</button>
    </p>
    <p>
        <h3>flat()</h3>
        此方法创建一个新数组，其中包含子数组上的holden元素，并将其平整到新数组中。请注意，此方法只能进行一个级别的深度。
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="flatfun()">flat()</button>
    </p>
    <p>
        <h3>flatMap()</h3>
        <p>flat缺点未克服</p>
        该方法将函数应用于数组的每个元素，然后将结果压缩为一个新数组。它在一个函数中结合了flat（）和map（）。
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="flatMapfun()">flatMap()</button>
    </p>
    <p>
        <h3>reduce()</h3>
        该.reduce()方法通过为数组的每个元素执行一个函数并累加结果，将数组缩减为单个值。
        <!-- <span style="color: red;">(原数组被修改)</span> -->
        <button onclick="reducefun()">reduce()</button>
    </p>

    <h1 style="color: rgb(6, 218, 16);">ES6新增新操作数组的方法</h1>
    <p>
        <h3>find()</h3>
        传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。
        <button onclick="findfun()">find()</button>
    </p>
    <p>
        <h3>findIndex()</h3>
        传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。
        <button onclick="findIndexfun()">findIndex()</button>
    </p>
    <p>
        <h3>fill()</h3>
        用新元素替换掉数组内的元素，可以指定替换下标范围。
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="fillfun()">fill()</button>
    </p>
    <p>
        <h3>copyWithin()</h3>
        选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。
        <span style="color: red;">(原数组被修改)</span>
        <button onclick="copyWithinfun()">copyWithin()</button>
    </p>
    <p>
        <h3>from()</h3>
        将类似数组的对象（array-like object）和可遍历（iterable）的对象转为真正的数组。
        <button onclick="fromfun()">from()</button>
    </p>
    <p>
        <h3>of()</h3>
        用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。
        <button onclick="offun()">of()</button>
    </p>
    <p>
        <h3>entries() 返回迭代器：返回键值对</h3>
        <pre>
        //数组
        const arr = ['a', 'b', 'c'];
        for(let v of arr.entries())
        {
        console.log(v)
        }
        // [0, 'a'] [1, 'b'] [2, 'c']

        //Set
        const arr = new Set(['a', 'b', 'c']);
        for(let v of arr.entries())
        {
        console.log(v)
        }
        // ['a', 'a'] ['b', 'b'] ['c', 'c']

        //Map
        const arr = new Map();
        arr.set('a', 'a');
        arr.set('b', 'b');
        for(let v of arr.entries())
        {
        console.log(v)
        }
        // ['a', 'a'] ['b', 'b']
       </pre>
        <h3>values() 返回迭代器：返回键值对的value</h3>
        <pre>
        //数组   
        const arr = ['a', 'b', 'c'];    
        for(let v of arr.values()) 
        {
            console.log(v)    
        }    
        //'a' 'b' 'c'
            
        //Set    
        const arr = new Set(['a', 'b', 'c']);    
        for(let v of arr.values()) 
        {
            console.log(v)    
        }  
        // 'a' 'b' 'c'
            
        //Map    
        const arr = new Map();
            arr.set('a', 'a');
            arr.set('b', 'b');    
        for(let v of arr.values()) 
        {
            console.log(v)    
        }    
        // 'a' 'b'
       </pre>
        <h3>keys() 返回迭代器：返回键值对的key</h3>
        <pre>
        //数组    
        const arr = ['a', 'b', 'c'];    
        for(let v of arr.keys()) 
        {
            console.log(v)    
        }   
        // 0 1 2
            
        //Set    
        const arr = new Set(['a', 'b', 'c']);    
        for(let v of arr.keys()) 
        {
            console.log(v)    
        }    
        // 'a' 'b' 'c'
            
        //Map    
        const arr = new Map();
            arr.set('a', 'a');
            arr.set('b', 'b');    
        for(let v of arr.keys()) 
        {
            console.log(v)    
        }    
        // 'a' 'b'
       </pre>
    </p>
    <p>
        <h3>includes()</h3>
        判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。
        indexOf 判断元素是否为 NaN，会判断错误。<br>
        用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。<br>
        译者注：includes() 方法区分大小写。
        <button onclick="includesfun()">includes()</button>
    </p>


    <script>
        function isArrayfun() {
            const arr = [1, 2, 3];
            console.log(Array.isArray(arr));
        }

        function toStringfun() {
            let arr = [
                "aaa", "bbb", "ccc"
            ];
            console.log(arr.toString());
            console.log(arr);
        }

        function joinfun() {
            let arr = new Array(3)
            arr[0] = "George"
            arr[1] = "John"
            arr[2] = "Thomas"
            console.log(arr.join()); //和toString()一样用逗号链接    
            console.log(arr.join("|")); //用参数链接
            console.log(arr.join("&")); //用参数链接
            console.log(arr.join(" ")); //如果是空格，真的用空格链接
            console.log(arr.join("")); //空字符是无缝连接
            console.log(arr);
        }

        let pushAndPop = [1, 2, 3];

        function pushfun() {
            console.log(`原数组${pushAndPop}`);
            let pusharray = pushAndPop.push("abc"); //在数组的最末尾添加一个元素;
            console.log(`修改后原数组${pushAndPop}`); //元素被修改了
            console.log(`修改后数组长度${pusharray}`); //返回值是数组的长度;
        }

        function popfun() {
            console.log(`原数组${pushAndPop}`);
            poparray = pushAndPop.pop(); //不需要参数;在数组的最末尾删除一项;
            console.log(`修改后原数组${pushAndPop}`); //元素被修改了
            console.log(`被删除的那一项（pop返回被删除的那个元素）：${poparray}`); //被删除的那一项
        }

        let unshiftAndshift = [4, 5, 6];

        function unshiftfun() {
            console.log(`原数组${unshiftAndshift}`);
            unshiftarray = unshiftAndshift.unshift("abc");
            //在数组的最前面添加一个元素;
            console.log(`原数组被修改${unshiftAndshift}`); //元素被修改了            
            console.log(`unshift返回的是数组的长度${unshiftarray}`); //返回值是数组的长度;
        }

        function shiftfun() {
            console.log(`原数组${unshiftAndshift}`);
            shiftarray = unshiftAndshift.shift(); //不需要参数;在数组的最前面删除一项;
            console.log(`原数组被修改${unshiftAndshift}`); //元素被修改了
            console.log(`shift返回的是被删除的那一项${shiftarray}`); //被删除的那一项
        }
    </script>
    <script>
        function reversefun() {
            let reversearray = [1, 2, 3, 4, 5];
            console.log(`原数组${reversearray}`);
            let res = reversearray.reverse();
            // [5,4,3,2,1]
            console.log(`结果${res}`);
            console.log('会修改原数组');
            console.log(`原数组${reversearray}`);
        }

        function sortfun() {
            let sortarray1 = [4, 5, 1, 3, 2, 7, 6];
            console.log(`原数组：${sortarray1}`);
            let sortres1 = sortarray1.sort();
            console.log('会修改原数组');
            console.log(`原数组：${sortarray1}`);
            console.log(`sort后的结果：${sortres1}`); // [1, 2, 3, 4, 5, 6, 7]
            console.log(sortarray1 === sortres1); // true 原数组被排序了(冒泡排序)  

            //默认还可以排列字母;
            let sortarray2 = ["c", "e", "d", "a", "b"];
            console.log(`原数组：${sortarray2}`);
            let sortres2 = sortarray2.sort();
            console.log(`原数组：${sortarray2}`);
            console.log('会修改原数组');
            console.log(`修改后的结果：${sortres2}`); // ["a", "b", "c", "d", "e"]
            console.log(sortarray2 === sortres2); // true 原数组被排序了(冒泡排序)  
        }

        function slicefun() {
            let arr = [2, 3, 4, 5];
            console.log(`原数组：${arr}`); //[2,3,4,5]
            console.log(`截取下标为1到3的数组(包括1不包括3，即截取下标为1和2)；${arr.slice(1, 3)}`); //[3,4]
            console.log(`原数组：${arr}`); //[2,3,4,5]
        }

        function splicefun() {
            let arr = [1, 2, 3, 4, 9, 6, "a", "b", "c"]
            console.log(`原数组：${arr}`);
            arr.splice(6); //从索引值为3截取到最后;(删除)
            console.log('arr.splice(6):从索引值为5截取到最后;(删除)');
            console.log(arr); // [1, 2, 3, 4, 9, 6]
            console.log('arr.splice(1, 2):(删除指定个数)从索引为1的开始删除2个');
            arr.splice(1, 2); //(删除指定个数)从索引为1的开始删除2个
            console.log(arr); // [1, 4, 9, 6]

            //替换 
            arr.splice(1, 3, "aaa", "bbb", "ccc");
            console.log('删除指定数并替换');
            console.log(arr); //[1, "aaa", "bbb", "ccc"]

            //    添加
            console.log('添加');
            arr.splice(4, 0, "aaa", "bbb", "ccc");
            console.log(arr); // [1, "aaa", "bbb", "ccc", "aaa", "bbb", "ccc"]
        }

        function concatfun() {
            let arr1 = [1, 2, 3];
            let arr2 = [4, 5];
            let arr3 = arr1.concat(arr2);
            console.log('不会修改原数组');
            console.log(`原数组${arr1}`); //[1, 2, 3]
            console.log(`结果${arr3}`); //[1, 2, 3, 4, 5]
        }

        function substringAndSubstr() {
            let str = '123456789';
            console.log(`substr只有一个参数：${str.substr(2)}`); //  "3456789"
            console.log(`substring只有一个参数：${str.substring(2)}`); //  "3456789"         
            console.log(`原字符串${str}`);
            console.log(`substring只有两个参数：${str.substr(2,5)}`); //  "34567"
            console.log(`substring只有两个参数：${str.substring(2,5)}`); //  "345"         
        }

        function indexOfAndLastIndexOf() {
            let a = [2, 9, 8, 6];
            let m = a.indexOf(9); // 0
            console.log(`indexOf找得到返回结果：${m}`);
            let n = a.indexOf(7); // -1  
            console.log(`indexOf找不到返回结果：${n}`);
            console.log('数组.indexOf的结果：找的到返回索引，找不到返回-1');
            if (a.indexOf(7) === -1) {
                console.log('未找到');
                // element doesn't exist in array    
            }

            let numbers = [2, 5, 9, 21, 56, 101, 88];
            let lastnum1 = numbers.lastIndexOf(9); // 3
            console.log(`lastIndexOf找得到结果：${lastnum1}`);
            let lastnum2 = numbers.lastIndexOf(7); // -1
            console.log(`lastIndexOf找不到结果：${lastnum2}`);
            console.log('参数：searchvalue：必需，要查找的项；startIndex：可选，起点位置的索引');

            let lastnum3 = numbers.lastIndexOf(9, 5); // 2
            console.log(`lastIndexOf两个参数找不到结果：${lastnum3}`);
            let lastnum4 = numbers.lastIndexOf(9, 101); // 2
            console.log(`lastIndexOf两个参数找不到结果：${lastnum4}`);
            let lastnum5 = numbers.lastIndexOf(9, 10); // 2
            console.log(`lastIndexOf两个参数找不到结果：${lastnum5}`);

            let lastnum6 = numbers.lastIndexOf(19, 5); // -1
            console.log(`lastIndexOf两个参数找不到结果：${lastnum6}`);
            let lastnum7 = numbers.lastIndexOf(19, 101); // -1
            console.log(`lastIndexOf两个参数找不到结果：${lastnum7}`);
            let lastnum8 = numbers.lastIndexOf(19, 10); // -1
            console.log(`lastIndexOf两个参数找不到结果：${lastnum8}`);

            let repeatarray = [1, 2, 5, 9, 2, 6, 9];
            let repeatnum1 = repeatarray.indexOf(2);
            console.log(`数组有重复元素indexOf与lastIndexOf对比（从前往后找indexOf值）：${repeatnum1}`);
            let repeatnum2 = repeatarray.lastIndexOf(2);
            console.log(`数组有重复元素indexOf与lastIndexOf对比（从后往前找lastIndexOf值）：${repeatnum2}`);
            let repeatnum3 = repeatarray.lastIndexOf(2, -1);
            console.log(`数组有重复元素lastIndexOf两个参数：${repeatnum3}`);
            let repeatnum4 = repeatarray.lastIndexOf(2, -4);
            console.log(`数组有重复元素lastIndexOf两个参数：${repeatnum4}`);
            let repeatnum6 = repeatarray.lastIndexOf(2, 5);
            console.log(`数组有重复元素lastIndexOf两个参数：${repeatnum6}`);
            let repeatnum8 = repeatarray.lastIndexOf(19, -5); // -1
            console.log(`数组有重复元素lastIndexOf两个参数找不到结果：${repeatnum8}`);
            let repeatnum9 = repeatarray.lastIndexOf(19, 5); // -1
            console.log(`数组有重复元素lastIndexOf两个参数找不到结果：${repeatnum9}`);
        }
    </script>
    <script>
        function everyfun() {
            let everyarray = [2, 5, 8, 3, 4];

            function isBigEnough(element) {
                return element < 10;
            }
            let res = everyarray.every(isBigEnough);
            console.log(`数组每一项都符合函数限定要求：${res}`);
        }

        function somefun() {
            let somearray = [2, 5, 8, 3, 4, 15];

            function isBigEnough(element) {
                return element > 10;
            }
            let res = somearray.some(isBigEnough);
            console.log(`数组任意一项符合函数限定要求结果为true：${res}`);
        }

        function filterfun() {
            var words = ["spray", "limit", "elite", "exuberant", "destruction", "present", "happy"];
            var longWords = words.filter(function (word) {
                return word.length > 6;
            });
            console.log(`数组过滤后的结果：${longWords}`);
            console.log(`原数组元素：${words}`);
        }

        function mapfun() {
            var numbers = [1, 5, 10, 15];
            var doubles = numbers.map(function (x) {
                return x * 2;
            });
            console.log(`用map遍历操作后的结果${doubles}`);
            console.log(`原数组元素：${numbers}`);
        }

        function forEachfun() {
            const items = ['item1', 'item2', 'item3'];
            const copy = [];
            items.forEach(function (item) {
                copy.push(item)
            });
            console.log(`forEach遍历后的结果：${copy}`);
            console.log(`原数组元素：${items}`);
        }

        function flatfun() {
            const flatarray = [
                [1, 2],
                [3, 4], 5
            ]
            let resarray = flatarray.flat()
            console.log(`flat函数运行结果：${resarray}`);
            console.log(`原数组：${flatarray}`);
        }

        function flatMapfun() {
            const flatMaparray = [
                [1],
                [2],
                [3],
                [4],
                [5]
            ]
            let res = flatMaparray.flatMap(arr => arr * 10)
            console.log(`原数组也是最后结果：${res}`);
        }
    </script>
    <script>
        function reducefun() {
            const nums = [1, 2, 3, 4, 5, 6];
            const numSum1 = nums.reduce((sum, num) => sum + num);
            console.log(`reduce函数运算结果${numSum1}`);

            const numSum2 = nums.reduce((sum, num) => sum + num, 1000);
            console.log(`reduce函数运算结果${numSum2}`);
        }
    </script>
    <script>
        function findfun() {
            const arr = [1, "3", 7, 6, "2"]
            // let findnum1=arr.find(3); //错误用法，find里面是一个回调函数
            let findnum1 = arr.find(n => typeof n === "string");
            console.log(`查找结果返回结果：${findnum1}`);
            console.log(`查找结果返回结果：${arr.find(n => typeof n === "number")}`)
        }

        function findIndexfun(params) {
            const arr = ['1', "2", 3, 3, "2"]
            console.log(`查找结果返回下标：${arr.findIndex(n =>typeof n === "number")}`)
        }

        function fillfun() {
            const arr = ['1', "2", 3, 3, "2"]
            // arr.fill(value, start, end)
            arr.fill('a', 1, 4);
            //从下标为1的元素开始替换，一直替换到下标为3，下标为4的不替换
            console.log(`原数组替换多个：${arr}`);
            arr.fill('b', 2, 3);
            console.log(`原数组替换单个：${arr}`);
        }

        function copyWithinfun() {
            // arr.copyWithin(target, start, end)
            const arr = [1, 2, 3, 4, 5]
            console.log(arr.copyWithin(1))
            // [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2 
            const arr3 = [1, 2, 3, 4, 5]
            console.log(arr3.copyWithin(-1))
            // 负数的话就倒数
            const arr1 = [1, 2, 3, 4, 5]
            console.log(arr1.copyWithin(3, 1))
            // [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3
            const arr2 = [1, 2, 3, 4, 5]
            console.log(arr2.copyWithin(2, 1, 3))
            console.log(arr2);
            // [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2
        }

        function fromfun() {
            const str = 'foot';
            console.log(`from方法遍历字符串转为数组${Array.from(str)}`); // ["f", "o", "o"]      
        }

        function offun() {
            let ofnum1 = Array();
            console.log(`Array：${ofnum1}`);
            let ofnum2 = Array(3);
            console.log(`Array(3)：${ofnum2}`);
            let ofnum3 = Array.of(3);
            console.log(`Array.of(3)：${ofnum3}`);
            let ofnum4 = Array.of(3, 7, 10);
            console.log(`Array.of(3,7,10)：${ofnum4}`);
        }

        function includesfun() {
            let a = [1, 2, 3];
            let res1 = a.includes(2); // true
            console.log(`includes运行结果：${res1}`);
            let res2 = a.includes(4); // false
            console.log(`includes运行结果：${res2}`);

            let str = 'this is my god!';
            // includes() 方法区分大小写。
            let res3 = str.includes('god');
            console.log(`用includes判断字符串含有指定字符串：${res3}`);
        }
    </script>
</body>

</html>